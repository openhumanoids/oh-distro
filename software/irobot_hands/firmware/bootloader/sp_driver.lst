   1               	# 1 "sp_driver.S"
   1               	;******************************************************************************
   0               	
   0               	
   2               	;*
   3               	;* XMEGA Self-programming driver assembly source file.
   4               	;*
   5               	;*      This file contains the low-level implementations for the
   6               	;*      XMEGA Self-programming driver. It is written for the GCC Assembler.
   7               	;*
   8               	;*      If any SPM instructions are used, the linker file must define
   9               	;*      a segment named bootloader which must be located in the device Boot section.
  10               	;*      This can be done by passing "-Wl,--section-start=.BOOT=0x020000" to the
  11               	;*      linker with the correct address for the boot section.
  12               	;*
  13               	;*      None of these routines clean up the NVM Command Register after use.
  14               	;*      It is therefore important to write NVM_CMD_NO_OPERATION_gc (0x00) to this
  15               	;*      register when you are finished using any of the functions in this driver.
  16               	;*
  17               	;*      For all routines, it is important that any interrupt handlers do not
  18               	;*      perform any NVM operations. The user must implement a scheme for mutually
  19               	;*      exclusive access to the NVM. However, the 4-cycle timeout will work fine,
  20               	;*      since writing to the Configuration Change Protection register (CCP)
  21               	;*      automatically disables interrupts for 4 instruction cycles.
  22               	;*
  23               	;*      Note on IAR calling convention:
  24               	;*         Scratch registers:   R18-R27, R30-R31
  25               	;*         Preserved registers: R2-R17, R28-R29
  26               	;*         Parameter registers: R8-R25 (2-,4-, or 8- byte alignment)
  27               	;*         Return registers:    R18-R25 (up to 64-bit)
  28               	;*
  29               	;* Application note:
  30               	;*      AVR1316: XMEGA Self-programming
  31               	;*
  32               	;* Documentation
  33               	;*      For comprehensive code documentation, supported compilers, compiler
  34               	;*      settings and supported devices see readme.html
  35               	;*
  36               	;*      Atmel Corporation: http:;www.atmel.com \n
  37               	;*      Support email: avr@atmel.com
  38               	;*
  39               	;* $Revision: 1153 $
  40               	;* $Date: 2007-12-18 09:48:23 +0100 (ti, 18 des 2007) $
  41               	;*
  42               	;* Copyright (c) 2007, Atmel Corporation All rights reserved.
  43               	;*
  44               	;* Redistribution and use in source and binary forms, with or without
  45               	;* modification, are permitted provided that the following conditions are met:
  46               	;*
  47               	;* 1. Redistributions of source code must retain the above copyright notice,
  48               	;* this list of conditions and the following disclaimer.
  49               	;*
  50               	;* 2. Redistributions in binary form must reproduce the above copyright notice,
  51               	;* this list of conditions and the following disclaimer in the documentation
  52               	;* and/or other materials provided with the distribution.
  53               	;*
  54               	;* 3. The name of ATMEL may not be used to endorse or promote products derived
  55               	;* from this software without specific prior written permission.
  56               	;*
  57               	;* THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  58               	;* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  59               	;* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
  60               	;* SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
  61               	;* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  62               	;* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  63               	;* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  64               	;* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  65               	;* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  66               	;* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  67               	;******************************************************************************
  68               	
  69               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM161__)
 126               	#  include <avr/io90pwm161.h>
 127               	#elif defined (__AVR_AT90PWM81__)
 128               	#  include <avr/io90pwm81.h>
 129               	#elif defined (__AVR_ATmega8U2__)
 130               	#  include <avr/iom8u2.h>
 131               	#elif defined (__AVR_ATmega16M1__)
 132               	#  include <avr/iom16m1.h>
 133               	#elif defined (__AVR_ATmega16U2__)
 134               	#  include <avr/iom16u2.h>
 135               	#elif defined (__AVR_ATmega16U4__)
 136               	#  include <avr/iom16u4.h>
 137               	#elif defined (__AVR_ATmega32C1__)
 138               	#  include <avr/iom32c1.h>
 139               	#elif defined (__AVR_ATmega32M1__)
 140               	#  include <avr/iom32m1.h>
 141               	#elif defined (__AVR_ATmega32U2__)
 142               	#  include <avr/iom32u2.h>
 143               	#elif defined (__AVR_ATmega32U4__)
 144               	#  include <avr/iom32u4.h>
 145               	#elif defined (__AVR_ATmega32U6__)
 146               	#  include <avr/iom32u6.h>
 147               	#elif defined (__AVR_ATmega64C1__)
 148               	#  include <avr/iom64c1.h>
 149               	#elif defined (__AVR_ATmega64M1__)
 150               	#  include <avr/iom64m1.h>
 151               	#elif defined (__AVR_ATmega128__)
 152               	#  include <avr/iom128.h>
 153               	#elif defined (__AVR_ATmega128A__)
 154               	#  include <avr/iom128a.h>
 155               	#elif defined (__AVR_ATmega1280__)
 156               	#  include <avr/iom1280.h>
 157               	#elif defined (__AVR_ATmega1281__)
 158               	#  include <avr/iom1281.h>
 159               	#elif defined (__AVR_ATmega1284__)
 160               	#  include <avr/iom1284.h>
 161               	#elif defined (__AVR_ATmega1284P__)
 162               	#  include <avr/iom1284p.h>
 163               	#elif defined (__AVR_ATmega128RFA1__)
 164               	#  include <avr/iom128rfa1.h>
 165               	#elif defined (__AVR_ATmega128RFA2__)
 166               	#  include <avr/iom128rfa2.h>
 167               	#elif defined (__AVR_ATmega128RFR2__)
 168               	#  include <avr/iom128rfr2.h>
 169               	#elif defined (__AVR_ATmega256RFA2__)
 170               	#  include <avr/iom256rfa2.h>
 171               	#elif defined (__AVR_ATmega256RFR2__)
 172               	#  include <avr/iom256rfr2.h>
 173               	#elif defined (__AVR_ATmega2560__)
 174               	#  include <avr/iom2560.h>
 175               	#elif defined (__AVR_ATmega2561__)
 176               	#  include <avr/iom2561.h>
 177               	#elif defined (__AVR_AT90CAN32__)
 178               	#  include <avr/iocan32.h>
 179               	#elif defined (__AVR_AT90CAN64__)
 180               	#  include <avr/iocan64.h>
 181               	#elif defined (__AVR_AT90CAN128__)
 182               	#  include <avr/iocan128.h>
 183               	#elif defined (__AVR_AT90USB82__)
 184               	#  include <avr/iousb82.h>
 185               	#elif defined (__AVR_AT90USB162__)
 186               	#  include <avr/iousb162.h>
 187               	#elif defined (__AVR_AT90USB646__)
 188               	#  include <avr/iousb646.h>
 189               	#elif defined (__AVR_AT90USB647__)
 190               	#  include <avr/iousb647.h>
 191               	#elif defined (__AVR_AT90USB1286__)
 192               	#  include <avr/iousb1286.h>
 193               	#elif defined (__AVR_AT90USB1287__)
 194               	#  include <avr/iousb1287.h>
 195               	#elif defined (__AVR_ATmega64RFA2__)
 196               	#  include <avr/iom64rfa2.h>
 197               	#elif defined (__AVR_ATmega64RFR2__)
 198               	#  include <avr/iom64rfr2.h>
 199               	#elif defined (__AVR_ATmega64__)
 200               	#  include <avr/iom64.h>
 201               	#elif defined (__AVR_ATmega64A__)
 202               	#  include <avr/iom64a.h>
 203               	#elif defined (__AVR_ATmega640__)
 204               	#  include <avr/iom640.h>
 205               	#elif defined (__AVR_ATmega644__) 
 206               	#  include <avr/iom644.h>
 207               	#elif (defined __AVR_ATmega644A__)
 208               	#include <avr/iom644a.h>
 209               	#elif defined (__AVR_ATmega644P__)
 210               	#  include <avr/iom644p.h>
 211               	#elif defined (__AVR_ATmega644PA__)
 212               	#  include <avr/iom644pa.h>
 213               	#elif defined (__AVR_ATmega645__)
 214               	#  include <avr/iom645.h>
 215               	#elif (defined __AVR_ATmega645A__)
 216               	#include <avr/iom645a.h>
 217               	#elif (defined __AVR_ATmega645P__)
 218               	#include <avr/iom645p.h>
 219               	#elif defined (__AVR_ATmega6450__)
 220               	#  include <avr/iom6450.h>
 221               	#elif (defined __AVR_ATmega6450A__)
 222               	#include <avr/iom6450a.h>
 223               	#elif (defined __AVR_ATmega6450P__)
 224               	#include <avr/iom6450p.h>
 225               	#elif defined (__AVR_ATmega649__)
 226               	#  include <avr/iom649.h>
 227               	#elif (defined __AVR_ATmega649A__)
 228               	#include <avr/iom649a.h>
 229               	#elif defined (__AVR_ATmega6490__)
 230               	#  include <avr/iom6490.h>
 231               	#elif (defined __AVR_ATmega6490A__)
 232               	#include <avr/iom6490a.h>
 233               	#elif (defined __AVR_ATmega6490P__)
 234               	#include <avr/iom6490p.h>
 235               	#elif defined (__AVR_ATmega649P__)
 236               	#  include <avr/iom649p.h>
 237               	#elif defined (__AVR_ATmega64HVE__)
 238               	#  include <avr/iom64hve.h>
 239               	#elif defined (__AVR_ATmega103__)
 240               	#  include <avr/iom103.h>
 241               	#elif defined (__AVR_ATmega32__)
 242               	#  include <avr/iom32.h>
 243               	#elif defined (__AVR_ATmega32A__)
 244               	#  include <avr/iom32a.h>
 245               	#elif defined (__AVR_ATmega323__)
 246               	#  include <avr/iom323.h>
 247               	#elif defined (__AVR_ATmega324P__)
 248               	#  include <avr/iom324p.h>
 249               	#elif (defined __AVR_ATmega324A__)
 250               	#include <avr/iom324a.h>
 251               	#elif defined (__AVR_ATmega324PA__)
 252               	#  include <avr/iom324pa.h>
 253               	#elif defined (__AVR_ATmega325__)
 254               	#  include <avr/iom325.h>
 255               	#elif (defined __AVR_ATmega325A__)
 256               	#include <avr/iom325a.h>
 257               	#elif defined (__AVR_ATmega325P__)
 258               	#  include <avr/iom325p.h>
 259               	#elif defined (__AVR_ATmega325PA__)
 260               	#  include <avr/iom325pa.h>  
 261               	#elif defined (__AVR_ATmega3250__) 
 262               	#  include <avr/iom3250.h>
 263               	#elif (defined __AVR_ATmega3250A__)
 264               	#include <avr/iom3250a.h>
 265               	#elif defined (__AVR_ATmega3250P__)
 266               	#  include <avr/iom3250p.h>
 267               	#elif defined (__AVR_ATmega3250PA__)
 268               	#  include <avr/iom3250pa.h>  
 269               	#elif defined (__AVR_ATmega328P__)
 270               	#  include <avr/iom328p.h>
 271               	#elif (defined __AVR_ATmega328__)
 272               	#include <avr/iom328.h>
 273               	#elif defined (__AVR_ATmega329__)
 274               	#  include <avr/iom329.h>
 275               	#elif (defined __AVR_ATmega329A__)
 276               	#include <avr/iom329a.h>
 277               	#elif defined (__AVR_ATmega329P__) 
 278               	#  include <avr/iom329p.h>
 279               	#elif (defined __AVR_ATmega329PA__)
 280               	#include <avr/iom329pa.h>
 281               	#elif (defined __AVR_ATmega3290PA__)
 282               	#include <avr/iom3290pa.h>
 283               	#elif defined (__AVR_ATmega3290__)
 284               	#  include <avr/iom3290.h>
 285               	#elif (defined __AVR_ATmega3290A__)
 286               	#include <avr/iom3290a.h>
 287               	#elif defined (__AVR_ATmega3290P__)
 288               	#  include <avr/iom3290.h>
 289               	#elif defined (__AVR_ATmega32HVB__)
 290               	#  include <avr/iom32hvb.h>
 291               	#elif defined (__AVR_ATmega32HVBREVB__)
 292               	#  include <avr/iom32hvbrevb.h>
 293               	#elif defined (__AVR_ATmega406__)
 294               	#  include <avr/iom406.h>
 295               	#elif defined (__AVR_ATmega16__)
 296               	#  include <avr/iom16.h>
 297               	#elif defined (__AVR_ATmega16A__)
 298               	#  include <avr/iom16a.h>
 299               	#elif defined (__AVR_ATmega161__)
 300               	#  include <avr/iom161.h>
 301               	#elif defined (__AVR_ATmega162__)
 302               	#  include <avr/iom162.h>
 303               	#elif defined (__AVR_ATmega163__)
 304               	#  include <avr/iom163.h>
 305               	#elif defined (__AVR_ATmega164P__)
 306               	#  include <avr/iom164p.h>
 307               	#elif (defined __AVR_ATmega164A__)
 308               	#include <avr/iom164a.h>
 309               	#elif defined (__AVR_ATmega164PA__)
 310               	#  include <avr/iom164pa.h>
 311               	#elif defined (__AVR_ATmega165__)
 312               	#  include <avr/iom165.h>
 313               	#elif (defined __AVR_ATmega165A__)
 314               	#include <avr/iom165a.h>
 315               	#elif defined (__AVR_ATmega165P__)
 316               	#  include <avr/iom165p.h>
 317               	#elif defined (__AVR_ATmega165PA__)
 318               	#  include <avr/iom165pa.h>
 319               	#elif defined (__AVR_ATmega168__)
 320               	#  include <avr/iom168.h>
 321               	#elif (defined __AVR_ATmega168A__)
 322               	#include <avr/iom168a.h>
 323               	#elif defined (__AVR_ATmega168P__)
 324               	#  include <avr/iom168p.h>
 325               	#elif defined (__AVR_ATmega168PA__)
 326               	#  include <avr/iom168pa.h>
 327               	#elif defined (__AVR_ATmega169__)
 328               	#  include <avr/iom169.h>
 329               	#elif (defined __AVR_ATmega169A__)
 330               	#include <avr/iom169a.h>
 331               	#elif defined (__AVR_ATmega169P__)
 332               	#  include <avr/iom169p.h>
 333               	#elif defined (__AVR_ATmega169PA__)
 334               	#  include <avr/iom169pa.h>
 335               	#elif defined (__AVR_ATmega8HVA__)
 336               	#  include <avr/iom8hva.h>
 337               	#elif defined (__AVR_ATmega16HVA__)
 338               	#  include <avr/iom16hva.h>
 339               	#elif defined (__AVR_ATmega16HVA2__)
 340               	#  include <avr/iom16hva2.h>
 341               	#elif defined (__AVR_ATmega16HVB__)
 342               	#  include <avr/iom16hvb.h>
 343               	#elif defined (__AVR_ATmega16HVBREVB__)
 344               	#  include <avr/iom16hvbrevb.h>
 345               	#elif defined (__AVR_ATmega26HVG__)
 346               	#  include <avr/iom26hvg.h>
 347               	#elif defined (__AVR_ATmega8__)
 348               	#  include <avr/iom8.h>
 349               	#elif defined (__AVR_ATmega8A__)
 350               	#  include <avr/iom8a.h>
 351               	#elif (defined __AVR_ATmega48A__)
 352               	#  include <avr/iom48a.h>
 353               	#elif defined (__AVR_ATmega48__)
 354               	#  include <avr/iom48.h>
 355               	#elif defined (__AVR_ATmega48PA__)
 356               	#  include <avr/iom48pa.h>
 357               	#elif defined (__AVR_ATmega48P__)
 358               	#  include <avr/iom48p.h>
 359               	#elif defined (__AVR_ATmega88__)
 360               	#  include <avr/iom88.h>
 361               	#elif (defined __AVR_ATmega88A__)
 362               	#  include <avr/iom88a.h>
 363               	#elif defined (__AVR_ATmega88P__)
 364               	#  include <avr/iom88p.h>
 365               	#elif defined (__AVR_ATmega48HVF__)
 366               	#  include <avr/iom48hvf.h>
 367               	#elif defined (__AVR_ATmega88PA__)
 368               	#  include <avr/iom88pa.h>
 369               	#elif defined (__AVR_ATmega8515__)
 370               	#  include <avr/iom8515.h>
 371               	#elif defined (__AVR_ATmega8535__)
 372               	#  include <avr/iom8535.h>
 373               	#elif defined (__AVR_AT90S8535__)
 374               	#  include <avr/io8535.h>
 375               	#elif defined (__AVR_AT90C8534__)
 376               	#  include <avr/io8534.h>
 377               	#elif defined (__AVR_AT90S8515__)
 378               	#  include <avr/io8515.h>
 379               	#elif defined (__AVR_AT90S4434__)
 380               	#  include <avr/io4434.h>
 381               	#elif defined (__AVR_AT90S4433__)
 382               	#  include <avr/io4433.h>
 383               	#elif defined (__AVR_AT90S4414__)
 384               	#  include <avr/io4414.h>
 385               	#elif defined (__AVR_ATtiny22__)
 386               	#  include <avr/iotn22.h>
 387               	#elif defined (__AVR_ATtiny26__)
 388               	#  include <avr/iotn26.h>
 389               	#elif defined (__AVR_AT90S2343__)
 390               	#  include <avr/io2343.h>
 391               	#elif defined (__AVR_AT90S2333__)
 392               	#  include <avr/io2333.h>
 393               	#elif defined (__AVR_AT90S2323__)
 394               	#  include <avr/io2323.h>
 395               	#elif defined (__AVR_AT90S2313__)
 396               	#  include <avr/io2313.h>
 397               	#elif defined (__AVR_ATtiny4__)
 398               	#  include <avr/iotn4.h>
 399               	#elif defined (__AVR_ATtiny5__)
 400               	#  include <avr/iotn5.h>
 401               	#elif defined (__AVR_ATtiny9__)
 402               	#  include <avr/iotn9.h>
 403               	#elif defined (__AVR_ATtiny10__)
 404               	#  include <avr/iotn10.h>
 405               	#elif defined (__AVR_ATtiny20__)
 406               	#  include <avr/iotn20.h>
 407               	#elif defined (__AVR_ATtiny40__)
 408               	#  include <avr/iotn40.h>
 409               	#elif defined (__AVR_ATtiny2313__)
 410               	#  include <avr/iotn2313.h>
 411               	#elif defined (__AVR_ATtiny2313A__)
 412               	#  include <avr/iotn2313a.h>
 413               	#elif defined (__AVR_ATtiny13__)
 414               	#  include <avr/iotn13.h>
 415               	#elif defined (__AVR_ATtiny13A__)
 416               	#  include <avr/iotn13a.h>
 417               	#elif defined (__AVR_ATtiny25__)
 418               	#  include <avr/iotn25.h>
 419               	#elif defined (__AVR_ATtiny4313__)
 420               	#  include <avr/iotn4313.h>
 421               	#elif defined (__AVR_ATtiny45__)
 422               	#  include <avr/iotn45.h>
 423               	#elif defined (__AVR_ATtiny85__)
 424               	#  include <avr/iotn85.h>
 425               	#elif defined (__AVR_ATtiny24__)
 426               	#  include <avr/iotn24.h>
 427               	#elif defined (__AVR_ATtiny24A__)
 428               	#  include <avr/iotn24a.h>
 429               	#elif defined (__AVR_ATtiny44__)
 430               	#  include <avr/iotn44.h>
 431               	#elif defined (__AVR_ATtiny44A__)
 432               	#  include <avr/iotn44a.h>
 433               	#elif defined (__AVR_ATtiny84__)
 434               	#  include <avr/iotn84.h>
 435               	#elif defined (__AVR_ATtiny84A__)
 436               	#  include <avr/iotn84a.h>  
 437               	#elif defined (__AVR_ATtiny841__)
 438               	#  include <avr/iotn841.h>
 439               	#elif defined (__AVR_ATtiny261__)
 440               	#  include <avr/iotn261.h>
 441               	#elif defined (__AVR_ATtiny261A__)
 442               	#  include <avr/iotn261a.h>
 443               	#elif defined (__AVR_ATtiny461__)
 444               	#  include <avr/iotn461.h>
 445               	#elif defined (__AVR_ATtiny461A__)
 446               	#  include <avr/iotn461a.h>
 447               	#elif defined (__AVR_ATtiny861__)
 448               	#  include <avr/iotn861.h>
 449               	#elif defined (__AVR_ATtiny861A__)
 450               	#  include <avr/iotn861a.h>
 451               	#elif defined (__AVR_ATtiny43U__)
 452               	#  include <avr/iotn43u.h>
 453               	#elif defined (__AVR_ATtiny48__)
 454               	#  include <avr/iotn48.h>
 455               	#elif defined (__AVR_ATtiny88__)
 456               	#  include <avr/iotn88.h>
 457               	#elif defined (__AVR_ATtiny828__)
 458               	#  include <avr/iotn828.h>
 459               	#elif defined (__AVR_ATtiny87__)
 460               	#  include <avr/iotn87.h>
 461               	#elif defined (__AVR_ATtiny167__)
 462               	#  include <avr/iotn167.h>
 463               	#elif defined (__AVR_ATtiny1634__)
 464               	#  include <avr/iotn1634.h>
 465               	#elif defined (__AVR_AT90SCR100__)
 466               	#  include <avr/io90scr100.h>
 467               	#elif defined (__AVR_ATMXT112SL__)
 468               	#  include <avr/iomxt112sl.h>
 469               	#elif defined (__AVR_ATMXT224__)
 470               	#  include <avr/iomxt224.h>
 471               	#elif defined (__AVR_ATMXT224E__)
 472               	#  include <avr/iomxt224e.h>
 473               	#elif defined (__AVR_ATMXT336S__)
 474               	#  include <avr/iomxt336s.h>
 475               	#elif defined (__AVR_ATMXT540S__)
 476               	#  include <avr/iomxt540s.h>
 477               	#elif defined (__AVR_ATMXT540SREVA__)
 478               	#  include <avr/iomxt540sreva.h>
 479               	#elif defined (__AVR_ATxmega16A4__)
 480               	#  include <avr/iox16a4.h>
 481               	#elif defined (__AVR_ATxmega16A4U__)
 482               	#  include <avr/iox16a4u.h>
 483               	#elif defined (__AVR_ATxmega16C4__)
 484               	#  include <avr/iox16c4.h>
 485               	#elif defined (__AVR_ATxmega16D4__)
 486               	#  include <avr/iox16d4.h>
 487               	#elif defined (__AVR_ATxmega32A4__)
 488               	#  include <avr/iox32a4.h>
 489               	#elif defined (__AVR_ATxmega32A4U__)
 490               	#  include <avr/iox32a4u.h>
 491               	#elif defined (__AVR_ATxmega32C4__)
 492               	#  include <avr/iox32c4.h>
 493               	#elif defined (__AVR_ATxmega32D4__)
 494               	#  include <avr/iox32d4.h>
 495               	#elif defined (__AVR_ATxmega32E5__)
 496               	#  include <avr/iox32e5.h>
 497               	#elif defined (__AVR_ATxmega32X1__)
 498               	#  include <avr/iox32x1.h>
 499               	#elif defined (__AVR_ATxmega64A1__)
 500               	#  include <avr/iox64a1.h>
 501               	#elif defined (__AVR_ATxmega64A1U__)
 502               	#  include <avr/iox64a1u.h>
 503               	#elif defined (__AVR_ATxmega64A3__)
 504               	#  include <avr/iox64a3.h>
   1               	/* Copyright (c) 2009-2010 Atmel Corporation
 505               	#elif defined (__AVR_ATxmega64A3U__)
 506               	#  include <avr/iox64a3u.h>
 507               	#elif defined (__AVR_ATxmega64A4U__)
 508               	#  include <avr/iox64a4u.h>
 509               	#elif defined (__AVR_ATxmega64B1__)
 510               	#  include <avr/iox64b1.h>
 511               	#elif defined (__AVR_ATxmega64B3__)
 512               	#  include <avr/iox64b3.h>
 513               	#elif defined (__AVR_ATxmega64C3__)
 514               	#  include <avr/iox64c3.h>
 515               	#elif defined (__AVR_ATxmega64D3__)
 516               	#  include <avr/iox64d3.h>
 517               	#elif defined (__AVR_ATxmega64D4__)
 518               	#  include <avr/iox64d4.h>
 519               	#elif defined (__AVR_ATxmega128A1__)
 520               	#  include <avr/iox128a1.h>
 521               	#elif defined (__AVR_ATxmega128A1U__)
 522               	#  include <avr/iox128a1u.h>
 523               	#elif defined (__AVR_ATxmega128A4U__)
 524               	#  include <avr/iox128a4u.h>
 525               	#elif defined (__AVR_ATxmega128A3__)
 526               	#  include <avr/iox128a3.h>
 527               	#elif defined (__AVR_ATxmega128A3U__)
 528               	#  include <avr/iox128a3u.h>
 529               	#elif defined (__AVR_ATxmega128B1__)
 530               	#  include <avr/iox128b1.h>
 531               	#elif defined (__AVR_ATxmega128B3__)
 532               	#  include <avr/iox128b3.h>
 533               	#elif defined (__AVR_ATxmega128C3__)
 534               	#  include <avr/iox128c3.h>
 535               	#elif defined (__AVR_ATxmega128D3__)
 536               	#  include <avr/iox128d3.h>
 537               	#elif defined (__AVR_ATxmega128D4__)
 538               	#  include <avr/iox128d4.h>
 539               	#elif defined (__AVR_ATxmega192A3__)
 540               	#  include <avr/iox192a3.h>
 541               	#elif defined (__AVR_ATxmega192A3U__)
 542               	#  include <avr/iox192a3u.h>
 543               	#elif defined (__AVR_ATxmega192C3__)
 544               	#  include <avr/iox192c3.h>
 545               	#elif defined (__AVR_ATxmega192D3__)
 546               	#  include <avr/iox192d3.h>
 547               	#elif defined (__AVR_ATxmega256A3__)
 548               	#  include <avr/iox256a3.h>
 549               	#elif defined (__AVR_ATxmega256A3U__)
 550               	#  include <avr/iox256a3u.h>
 551               	#elif defined (__AVR_ATxmega256A3B__)
 552               	#  include <avr/iox256a3b.h>
 553               	#elif defined (__AVR_ATxmega256A3BU__)
 554               	#  include <avr/iox256a3bu.h>
 555               	#elif defined (__AVR_ATxmega256C3__)
 556               	#  include <avr/iox256c3.h>
 557               	#elif defined (__AVR_ATxmega256D3__)
 558               	#  include <avr/iox256d3.h>
 559               	#elif defined (__AVR_ATxmega384C3__)
 560               	#  include <avr/iox384c3.h>
 561               	#elif defined (__AVR_ATxmega384D3__)
 562               	#  include <avr/iox384d3.h>
 563               	#elif defined (__AVR_ATA5790__)
 564               	#  include <avr/ioa5790.h>
 565               	#elif defined (__AVR_ATA5790N__)
 566               	#  include <avr/ioa5790n.h>
 567               	#elif defined (__AVR_ATA5272__)
 568               	#  include <avr/ioa5272.h>
 569               	#elif defined (__AVR_ATA5505__)
 570               	#  include <avr/ioa5505.h>
 571               	#elif defined (__AVR_ATA5795__)
 572               	#  include <avr/ioa5795.h>
 573               	#elif defined (__AVR_ATA5831__)
 574               	#  include <avr/ioa5831.h>
 575               	#elif defined (__AVR_ATA6285__)
 576               	#  include <avr/ioa6285.h>
 577               	#elif defined (__AVR_ATA6286__)
 578               	#  include <avr/ioa6286.h>
 579               	#elif defined (__AVR_ATA6289__)
 580               	#  include <avr/ioa6289.h>
 581               	/* avr1: the following only supported for assembler programs */
 582               	#elif defined (__AVR_ATtiny28__)
 583               	#  include <avr/iotn28.h>
 584               	#elif defined (__AVR_AT90S1200__)
 585               	#  include <avr/io1200.h>
 586               	#elif defined (__AVR_ATtiny15__)
 587               	#  include <avr/iotn15.h>
 588               	#elif defined (__AVR_ATtiny12__)
 589               	#  include <avr/iotn12.h>
 590               	#elif defined (__AVR_ATtiny11__)
 591               	#  include <avr/iotn11.h>
 592               	#elif defined (__AVR_M3000__)
 593               	#  include <avr/iom3000.h>
 594               	#else
 595               	#  if !defined(__COMPILING_AVR_LIBC__)
 596               	#    warning "device type not defined"
 597               	#  endif
 598               	#endif
 599               	
 600               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 601               	
 602               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 603               	
 604               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 605               	
 606               	/* Include fuse.h after individual IO header files. */
 607               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 608               	
 609               	/* Include lock.h after individual IO header files. */
 610               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 611               	
  70               	;#include "Flash_Defines.h"
  71               	
  72               	/* Define the size of the flash page if not defined in the header files. */
  73               	#ifndef APP_SECTION_PAGE_SIZE
  74               		#error  APP_SECTION_PAGE_SIZE must be defined if not defined in header files.
  75               		//#define APP_SECTION_PAGE_SIZE 512
  76               	#endif /*APP_SECTION_PAGE_SIZE*/
  77               	
  78               	/* Defines not yet included in header file. */
  79               	#define NVM_CMD_NO_OPERATION_gc (0x00<<0)	// Noop/Ordinary LPM
  80               	#define NVM_CMD_READ_USER_SIG_ROW_gc (0x01<<0)	// Read user signature row
  81               	#define NVM_CMD_READ_CALIB_ROW_gc (0x02<<0)	// Read calibration row
  82               	#define NVM_CMD_READ_EEPROM_gc (0x06<<0)	// Read EEPROM
  83               	#define NVM_CMD_READ_FUSES_gc (0x07<<0)	// Read fuse byte
  84               	#define NVM_CMD_WRITE_LOCK_BITS_gc (0x08<<0)	// Write lock bits
  85               	#define NVM_CMD_ERASE_USER_SIG_ROW_gc (0x18<<0)	// Erase user signature row
  86               	#define NVM_CMD_WRITE_USER_SIG_ROW_gc (0x1A<<0)	// Write user signature row
  87               	#define NVM_CMD_ERASE_APP_gc (0x20<<0)	// Erase Application Section
  88               	#define NVM_CMD_ERASE_APP_PAGE_gc (0x22<<0)	// Erase Application Section page
  89               	#define NVM_CMD_LOAD_FLASH_BUFFER_gc (0x23<<0)	// Load Flash page buffer
  90               	#define NVM_CMD_WRITE_APP_PAGE_gc (0x24<<0)	// Write Application Section page
  91               	#define NVM_CMD_ERASE_WRITE_APP_PAGE_gc (0x25<<0)	// Erase-and-write Application Section page
  92               	#define NVM_CMD_ERASE_FLASH_BUFFER_gc (0x26<<0)	// Erase/flush Flash page buffer
  93               	#define NVM_CMD_ERASE_BOOT_PAGE_gc (0x2A<<0)	// Erase Boot Section page
  94               	#define NVM_CMD_WRITE_BOOT_PAGE_gc (0x2C<<0)	// Write Boot Section page
  95               	#define NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc (0x2D<<0)	// Erase-and-write Boot Section page
  96               	#define NVM_CMD_ERASE_EEPROM_gc (0x30<<0)	// Erase EEPROM
  97               	#define NVM_CMD_ERASE_EEPROM_PAGE_gc (0x32<<0)	// Erase EEPROM page
  98               	#define NVM_CMD_LOAD_EEPROM_BUFFER_gc (0x33<<0)	// Load EEPROM page buffer
  99               	#define NVM_CMD_WRITE_EEPROM_PAGE_gc (0x34<<0)	// Write EEPROM page
 100               	#define NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc (0x35<<0)	// Erase-and-write EEPROM page
 101               	#define NVM_CMD_ERASE_EEPROM_BUFFER_gc (0x36<<0)	// Erase/flush EEPROM page buffer
 102               	#define NVM_CMD_APP_CRC_gc (0x38<<0)	// Generate Application section CRC
 103               	#define NVM_CMD_BOOT_CRC_gc (0x39<<0)	// Generate Boot Section CRC
 104               	#define NVM_CMD_FLASH_RANGE_CRC_gc (0x3A<<0)	// Generate Flash Range CRC
 105               	#define CCP_SPM_gc (0x9D<<0)	// SPM Instruction Protection
 106               	#define CCP_IOREG_gc (0xD8<<0)	// IO Register Protection
 107               	
 108               	
 109               	
 110               	; ---
 111               	; This routine reads a byte from flash given by the address in
 112               	; R25:R24:R23:R22.
 113               	;
 114               	; Input:
 115               	;     R25:R24:R23:R22.
 116               	;
 117               	; Returns:
 118               	;     R24 - Read byte.
 119               	; ---
 120               	
 121               	.section .text
 122               	.global SP_ReadByte
 123               	
 124               	SP_ReadByte:
 125:sp_driver.S   **** 	in	r19, RAMPZ      ; Save RAMPZ.
 126:sp_driver.S   **** 	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
 127:sp_driver.S   **** 	movw	ZL, r22         ; Move the low bytes to the Z pointer
 128:sp_driver.S   **** 	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
 129:sp_driver.S   **** 	out	RAMPZ, r19      ; Restore RAMPZ register.
 130:sp_driver.S   **** 	ret
 131               	
 132               	
 133               	
 134               	; ---
 135               	; This routine reads a word from flash given by the address in
 136               	; R25:R24:R23:R22.
 137               	;
 138               	; Input:
 139               	;     R25:R24:R23:R22.
 140               	;
 141               	; Returns:
 142               	;     R25:R24 - Read word.
 143               	; ---
 144               	
 145               	.section .text
 146               	.global SP_ReadWord
 147               	
 148               	SP_ReadWord:
 149:sp_driver.S   **** 	in	r19, RAMPZ      ; Save RAMPZ.
 150:sp_driver.S   **** 	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
 151:sp_driver.S   **** 	movw	ZL, r22         ; Move the low bytes to the Z pointer
 152:sp_driver.S   **** 	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
 153:sp_driver.S   **** 	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
 154:sp_driver.S   **** 	out	RAMPZ, r19      ; Restore RAMPZ register.
 155:sp_driver.S   **** 	ret
 156               	
 157               	
 158               	
 159               	; ---
 160               	; This routine reads the calibration byte given by the index in R24.
 161               	;
 162               	; Input:
 163               	;     R24 - Byte index.
 164               	;
 165               	; Returns:
 166               	;     R24 - Calibration byte.
 167               	; ---
 168               	
 169               	.section .text
 170               	.global SP_ReadCalibrationByte	
 171               	
 172               	SP_ReadCalibrationByte:
 173:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
 174:sp_driver.S   **** 	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
 175               	
 176               	
 177               	
 178               	; ---
 179               	; This routine reads the user signature byte given by the index in R25:R24.
 180               	;
 181               	; Input:
 182               	;     R25:R24 - Byte index.
 183               	;
 184               	; Returns:
 185               	;     R24 - Signature byte.
 186               	; ---
 187               	
 188               	.section .text	
 189               	.global SP_ReadUserSignatureByte
 190               	
 191               	SP_ReadUserSignatureByte:
 192:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
 193:sp_driver.S   **** 	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
 194               	
 195               	
 196               	
 197               	; ---
 198               	; This routine reads the fuse byte given by the index in R24.
 199               	;
 200               	; Input:
 201               	;     R24 - Byte index.
 202               	;
 203               	; Returns:
 204               	;     R24 - Fuse byte.
 205               	; ---
 206               	
 207               	.section .text	
 208               	.global SP_ReadFuseByte
 209               	
 210               	SP_ReadFuseByte:
 211:sp_driver.S   **** 	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
 212:sp_driver.S   **** 	clr	r24                         ; Prepare a zero.
 213:sp_driver.S   **** 	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
 214:sp_driver.S   **** 	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
 215:sp_driver.S   **** 	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
 216:sp_driver.S   **** 	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
 217:sp_driver.S   **** 	movw	r24, r22                    ; Move low byte to 1 byte return address.
 218:sp_driver.S   **** 	ret
 219               	
 220               	
 221               	
 222               	; ---
 223               	; This routine sets the lock bits from R24. Note that unlocking is only
 224               	; possible by doing a full chip erase, not available from software.
 225               	;
 226               	; Input:
 227               	;     R24 - Lock bits.
 228               	;
 229               	; Returns:
 230               	;     Nothing.
 231               	; ---
 232               	
 233               	.section .text	
 234               	.global SP_WriteLockBits
 235               	
 236               	SP_WriteLockBits:
 237:sp_driver.S   **** 	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
 238:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
 239:sp_driver.S   **** 	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
 240               	
 241               	
 242               	
 243               	; ---
 244               	; This routine reads the lock bits.
 245               	;
 246               	; Input:
 247               	;     Nothing.
 248               	;
 249               	; Returns:
 250               	;     R24 - Lock bits.
 251               	; ---
 252               	
 253               	.section .text		
 254               	.global SP_ReadLockBits
 255               	
 256               	SP_ReadLockBits:
 257:sp_driver.S   **** 	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
 258:sp_driver.S   **** 	ret
 259               	
 260               	
 261               	
 262               	; ---
 263               	; This routine erases the user signature row.
 264               	;
 265               	; Input:
 266               	;     Nothing.
 267               	;
 268               	; Returns:
 269               	;     Nothing.
 270               	; ---
 271               	
 272               	.section .text
 273               	.global SP_EraseUserSignatureRow
 274               	
 275               	SP_EraseUserSignatureRow:
 276:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 277:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
 278:sp_driver.S   **** 	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
 279               	
 280               	
 281               	
 282               	; ---
 283               	; This routine writes the flash buffer to the user signature row.
 284               	;
 285               	; Input:
 286               	;     Nothing.
 287               	;
 288               	; Returns:
 289               	;     Nothing.
 290               	; ---
 291               	
 292               	.section .text
 293               	.global SP_WriteUserSignatureRow
 294               	
 295               	SP_WriteUserSignatureRow:
 296:sp_driver.S   **** 	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
 297:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
 298:sp_driver.S   **** 	jmp	SP_CommonSPM                        ; Jump to common SPM code.
 299               	
 300               	
 301               	
 302               	; ---
 303               	; This routine erases the entire application section.
 304               	;
 305               	; Input:
 306               	;     Nothing.
 307               	;
 308               	; Returns:
 309               	;     Nothing.
 310               	; ---
 311               	
 312               	.section .text
 313               	.global SP_EraseApplicationSection
 314               	
 315               	SP_EraseApplicationSection:
 316:sp_driver.S   **** 	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
 317:sp_driver.S   **** 	clr	r24                        ; Prepare a zero.
 318:sp_driver.S   **** 	clr	r25
 319:sp_driver.S   **** 	out	RAMPZ, r24                 ; Point into Application area.
 320:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
 321:sp_driver.S   **** 	jmp	SP_CommonSPM               ; Jump to common SPM code.
 322               	
 323               	
 324               	
 325               	; ---
 326               	; This routine erases the page at address R25:R24:R23:R22 in the application
 327               	; section. The address can point anywhere inside the page.
 328               	;
 329               	; Input:
 330               	;     R25:R24:R23:R22 - Byte address into Flash page.
 331               	;
 332               	; Returns:
 333               	;     Nothing.
 334               	; ---
 335               	
 336               	.section .text	
 337               	.global SP_EraseApplicationPage
 338               	
 339               	SP_EraseApplicationPage:
 340:sp_driver.S   **** 	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
 341:sp_driver.S   **** 	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
 342:sp_driver.S   **** 	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
 343:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
 344:sp_driver.S   **** 	jmp	SP_CommonSPM                    ; Jump to common SPM code.
 345               	
 346               	
 347               	
 348               	; ---
 349               	; This routine writes the word from R23:R22 into the Flash page buffer at
 350               	; address R25:R24.
 351               	;
 352               	; Input:
 353               	;     R25:R24 - Byte address into Flash page.
 354               	;     R23:R22 - Word to write.
 355               	;
 356               	; Returns:
 357               	;     Nothing.
 358               	; ---
 359               	
 360               	.section .text
 361               	.global SP_LoadFlashWord
 362               	
 363               	SP_LoadFlashWord:
 364:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 365:sp_driver.S   **** 	movw	r0, r22                            ; Prepare flash word in R1:R0.
 366:sp_driver.S   **** 	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
 367:sp_driver.S   **** 	jmp	SP_CommonSPM                       ; Jump to common SPM code.
 368               	
 369               	
 370               	
 371               	; ---
 372               	; This routine writes an entire page from the SRAM buffer at
 373               	; address R25:R24 into the Flash page buffer.
 374               	;
 375               	; Note that you must define "-Wl,--section-start=.BOOT=0x020000" for the
 376               	; linker to place this function in the boot section with the correct address.
 377               	;
 378               	; Input:
 379               	;     R25:R24 - 16-bit pointer to SRAM buffer.
 380               	;
 381               	; Returns:
 382               	;     Nothing.
 383               	; ---
 384               			
 385               	.section .text
 386               	.global SP_LoadFlashPage
 387               	
 388               	SP_LoadFlashPage:
 389:sp_driver.S   **** 	clr	ZL              ; Clear low byte of Z, to indicate start of page.
 390:sp_driver.S   **** 	clr	ZH              ; Clear high byte of Z, to indicate start of page.
 391               	
 392:sp_driver.S   **** 	out	RAMPX, r1       ; Clear RAMPX pointer.
 393:sp_driver.S   **** 	movw	XL, r24         ; Load X with data buffer address.
 394               	
 395:sp_driver.S   **** 	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
 396:sp_driver.S   **** 	sts	NVM_CMD, r20                       ; Load it into NVM command register.
 397               	
 398               	#if APP_SECTION_PAGE_SIZE > 512
 399               		ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8)
 400               	#endif
 401               	
 402:sp_driver.S   **** 	ldi	r21, ((APP_SECTION_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
 403:sp_driver.S   **** 	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
 404               	
 405               	SP_LoadFlashPage_1:
 406:sp_driver.S   **** 	ld	r0, X+         ; Load low byte from buffer into R0.
 407:sp_driver.S   **** 	ld	r1, X+         ; Load high byte from buffer into R1.
 408:sp_driver.S   **** 	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
 409:sp_driver.S   **** 	spm                    ; Self-program.
 410:sp_driver.S   **** 	adiw	ZL, 2          ; Move Z to next Flash word.
 411               	
 412               	#if APP_SECTION_PAGE_SIZE > 512
 413               		subi	r21, 1         ; Decrement word count.
 414               		sbci	r22, 0
 415               	#else
 416:sp_driver.S   **** 	dec	r21            ; Decrement word count.
 417               	#endif
 418               	
 419:sp_driver.S   **** 	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
 420               	
 421:sp_driver.S   **** 	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
 422:sp_driver.S   **** 	ret
 423               	
 424               	
 425               	
 426               	; ---
 427               	; This routine reads an entire Flash page from address R23:R22:R21:R20 into the
 428               	; SRAM buffer at address R25:R24.
 429               	;
 430               	;
 431               	; Input:
 432               	;     R23:R22:R21:R20 - Flash byte address.
 433               	;     R25:R24 - 16-bit pointer to SRAM buffer.
 434               	;
 435               	; Returns:
 436               	;     Nothing.
 437               	; ---
 438               	
 439               	.section .text		
 440               	.global SP_ReadFlashPage
 441               	
 442               	SP_ReadFlashPage:
 443               	
 444:sp_driver.S   **** 	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
 445:sp_driver.S   **** 	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
 446:sp_driver.S   **** 	movw    ZL, r20                      ; Load Z with Flash address.
 447               	
 448:sp_driver.S   **** 	out	RAMPX, r1                    ; Load RAMPX with data pointer
 449:sp_driver.S   **** 	movw	XL, r24                      ; Load X with data buffer address.
 450               	
 451:sp_driver.S   **** 	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
 452:sp_driver.S   **** 	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
 453               	
 454               	#if APP_SECTION_PAGE_SIZE > 512
 455               		ldi	r22, ((APP_SECTION_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
 456               	#endif	
 457               	
 458:sp_driver.S   **** 	ldi	r21, ((APP_SECTION_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
 459               	
 460               	SP_ReadFlashPage_1:
 461:sp_driver.S   **** 	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
 462:sp_driver.S   **** 	elpm	r25, Z+
 463:sp_driver.S   **** 	st	X+, r24                         ; Write bytes to buffer.
 464:sp_driver.S   **** 	st	X+, r25
 465               	
 466               	#if APP_SECTION_PAGE_SIZE > 512
 467               		subi	r21, 1                          ; Decrement word count.
 468               		sbci	r22, 0
 469               	#else
 470:sp_driver.S   **** 	dec	r21                             ; Decrement word count.
 471               	#endif	
 472               	
 473:sp_driver.S   **** 	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
 474               	
 475:sp_driver.S   **** 	out	RAMPZ, r19
 476:sp_driver.S   **** 	ret
 477               	
 478               	
 479               	
 480               	; ---
 481               	; This routine writes the page buffer to the Flash page at address R25:R24:R23:R22
 482               	; in the application section. The address can point anywhere inside the page.
 483               	;
 484               	; Input:
 485               	;     R25:R24:R23:R22 - Byte address into Flash page.
 486               	;
 487               	; Returns:
 488               	;     Nothing.
 489               	; ---
 490               	
 491               	.section .text		
 492               	.global SP_WriteApplicationPage
 493               	
 494               	SP_WriteApplicationPage:
 495:sp_driver.S   **** 	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
 496:sp_driver.S   **** 	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
 497:sp_driver.S   **** 	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
 498:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
 499:sp_driver.S   **** 	jmp	SP_CommonSPM                     ; Jump to common SPM code.
 500               	
 501               	
 502               	
 503               	; ---
 504               	; This routine erases first and then writes the page buffer to the
 505               	; Flash page at address R25:R24:R23:R22 in the application section. The address
 506               	; can point anywhere inside the page.
 507               	;
 508               	; Input:
 509               	;     R25:R24:R23:R22 - Byte address into Flash page.
 510               	;
 511               	; Returns:
 512               	;     Nothing.
 513               	; ---
 514               	
 515               	.section .text
 516               	.global SP_EraseWriteApplicationPage
 517               	
 518               	SP_EraseWriteApplicationPage:
 519:sp_driver.S   **** 	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
 520:sp_driver.S   **** 	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
 521:sp_driver.S   **** 	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
 522:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
 523:sp_driver.S   **** 	jmp	SP_CommonSPM                          ; Jump to common SPM code.
 524               	
 525               	
 526               	
 527               	; ---
 528               	; This routine flushes the Flash page buffer.
 529               	;
 530               	; Input:
 531               	;     Nothing.
 532               	;
 533               	; Returns:
 534               	;     Nothing.
 535               	; ---
 536               	
 537               	.section .text		
 538               	.global SP_EraseFlashBuffer
 539               	
 540               	SP_EraseFlashBuffer:
 541:sp_driver.S   **** 	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
 542:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
 543:sp_driver.S   **** 	jmp	SP_CommonSPM                        ; Jump to common SPM code.
 544               	
 545               	
 546               	
 547               	; ---
 548               	; This routine erases the page at address R25:R24:R23:R22 in the Boot section. The
 549               	; address can point anywhere inside the page.
 550               	;
 551               	; Input:
 552               	;     R25:R24:R23:R22 - Byte address into Flash page.
 553               	;
 554               	; Returns:
 555               	;     Nothing.
 556               	; ---
 557               	
 558               	.section .text		
 559               	.global SP_EraseBootPage
 560               	
 561               	SP_EraseBootPage:
 562:sp_driver.S   **** 	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
 563:sp_driver.S   **** 	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
 564:sp_driver.S   **** 	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
 565:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
 566:sp_driver.S   **** 	jmp	SP_CommonSPM                       ; Jump to common SPM code.
 567               	
 568               	
 569               	
 570               	; ---
 571               	; This routine writes the page buffer to the Flash page at address R25:R24:R23:R22
 572               	; in the BOOT section. The address can point anywhere inside the page.
 573               	;
 574               	; Input:
 575               	;     R25:R24:R23:R22 - Byte address into Flash page.
 576               	;
 577               	; Returns:
 578               	;     Nothing.
 579               	; ---
 580               	
 581               	.section .text		
 582               	.global SP_WriteBootPage
 583               	
 584               	SP_WriteBootPage:
 585:sp_driver.S   **** 	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
 586:sp_driver.S   **** 	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
 587:sp_driver.S   **** 	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
 588:sp_driver.S   **** 	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
 589:sp_driver.S   **** 	jmp	SP_CommonSPM                     ; Jump to common SPM code.
 590               	
 591               	
 592               	
 593               	; ---
 594               	; This routine erases first and then writes the page buffer to the
 595               	; Flash page at address R25:R24:R23:R22 in the Boot section. The address
 596               	; can point anywhere inside the page.
 597               	;
 598               	; Input:
 599               	;     R25:R24:R23:R22 - Byte address into Flash page.
 600               	;
 601               	; Returns:
 602               	;     Nothing.
 603               	; ---
 604               	
 605               	.section .text		
 606               	.global SP_EraseWriteBootPage
 607               	
 608               	SP_EraseWriteBootPage:
 609:sp_driver.S   **** 	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
 610:sp_driver.S   **** 	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
 611:sp_driver.S   **** 	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
 612:sp_driver.S   **** 	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
 613:sp_driver.S   **** 	jmp	SP_CommonSPM                           ; Jump to common SPM code.
 614               	
 615               	
 616               	
 617               	; ---
 618               	; This routine calculates a CRC for the application section.
 619               	;
 620               	; Input:
 621               	;     Nothing.
 622               	;
 623               	; Returns:
 624               	;     R25:R24:R23:R22 - 32-bit CRC result (actually only 24-bit used).
 625               	; ---
 626               	
 627               	.section .text	
 628               	.global SP_ApplicationCRC
 629               	
 630               	SP_ApplicationCRC:
 631:sp_driver.S   **** 	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
 632:sp_driver.S   **** 	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
 633               	
 634               	
 635               	
 636               	; ---
 637               	; This routine calculates a CRC for the Boot section.
 638               	;
 639               	; Input:
 640               	;     Nothing.
 641               	;
 642               	; Returns:
 643               	;     R25:R24:R23:R22 - 32-bit CRC result (actually only 24-bit used).
 644               	; ---
 645               	
 646               	.section .text
 647               	.global SP_BootCRC
 648               	
 649               	SP_BootCRC:
 650:sp_driver.S   **** 	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
 651:sp_driver.S   **** 	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
 652               	
 653               	
 654               	
 655               	; ---
 656               	; This routine locks all further access to SPM operations until next reset.
 657               	;
 658               	; Input:
 659               	;     Nothing.
 660               	;
 661               	; Returns:
 662               	;     Nothing.
 663               	; ---
 664               	
 665               	.section .text
 666               	.global SP_LockSPM
 667               	
 668               	SP_LockSPM:
 669:sp_driver.S   **** 	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
 670:sp_driver.S   **** 	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
 671:sp_driver.S   **** 	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
 672:sp_driver.S   **** 	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
 673:sp_driver.S   **** 	ret
 674               		
 675               	
 676               	
 677               	; ---
 678               	; This routine wait for the SPM to finish and clears the command register.
 679               	;
 680               	; Note that this routine is blocking, and will halt any execution until the SPM
 681               	; is finished.
 682               	;
 683               	; Input:
 684               	;     Nothing.
 685               	;
 686               	; Returns:
 687               	;     Nothing.
 688               	; ---
 689               	
 690               	.section .text
 691               	.global SP_WaitForSPM		
 692               	
 693               	SP_WaitForSPM:
 694:sp_driver.S   **** 	lds	r18, NVM_STATUS     ; Load the NVM Status register.
 695:sp_driver.S   **** 	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
 696:sp_driver.S   **** 	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
 697:sp_driver.S   **** 	clr	r18
 698:sp_driver.S   **** 	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
 699:sp_driver.S   **** 	ret
 700               	
 701               	
 702               	
 703               	; ---
 704               	; This routine is called by several other routines, and contains common code
 705               	; for executing an NVM command, including the return statement itself.
 706               	;
 707               	; If the operation (NVM command) requires the NVM Address registers to be
 708               	; prepared, this must be done before jumping to this routine.
 709               	;
 710               	; Note that R25:R24:R23:R22 is used for returning results, even if the
 711               	; C-domain calling function only expects a single byte or even void.
 712               	;
 713               	; Input:
 714               	;     R20 - NVM Command code.
 715               	;
 716               	; Returns:
 717               	;     R25:R24:R23:R22 - 32-bit result from NVM operation.
 718               	; ---
 719               	
 720               	.section .text		
 721               	
 722               	SP_CommonCMD:
 723:sp_driver.S   **** 	sts	NVM_CMD, r20        ; Load command into NVM Command register.
 724:sp_driver.S   **** 	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
 725:sp_driver.S   **** 	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
 726:sp_driver.S   **** 	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
 727:sp_driver.S   **** 	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
 728:sp_driver.S   **** 	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
 729:sp_driver.S   **** 	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
 730:sp_driver.S   **** 	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
 731:sp_driver.S   **** 	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
 732:sp_driver.S   **** 	ret
 733               	
 734               	
 735               	
 736               	; ---
 737               	; This routine is called by several other routines, and contains common code
 738               	; for executing an LPM command, including the return statement itself.
 739               	;
 740               	; Note that R24 is used for returning results, even if the
 741               	; C-domain calling function expects a void.
 742               	;
 743               	; Input:
 744               	;     R25:R24 - Low bytes of Z pointer.
 745               	;     R20     - NVM Command code.
 746               	;
 747               	; Returns:
 748               	;     R24     - Result from LPM operation.
 749               	; ---
 750               	
 751               	.section .text		
 752               	
 753               	SP_CommonLPM:
 754:sp_driver.S   **** 	movw	ZL, r24             ; Load index into Z.
 755:sp_driver.S   **** 	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
 756:sp_driver.S   **** 	lpm	r24,Z
 757:sp_driver.S   **** 	ret
 758               	
 759               	
 760               	
 761               	; ---
 762               	; This routine is called by several other routines, and contains common code
 763               	; for executing an SPM command, including the return statement itself.
 764               	;
 765               	; If the operation (SPM command) requires the R1:R0 registers to be
 766               	; prepared, this must be done before jumping to this routine.
 767               	;
 768               	; Note that you must define "-Wl,--section-start=.BOOT=0x020000" for the
 769               	; linker to place this function in the boot section with the correct address.
 770               	;
 771               	; Input:
 772               	;     R1:R0    - Optional input to SPM command.
 773               	;     R25:R24  - Low bytes of Z pointer.
 774               	;     R20      - NVM Command code.
 775               	;
 776               	; Returns:
 777               	;     Nothing.
 778               	; ---
 779               	
 780               	.section .text
 781               	
 782               	SP_CommonSPM:
 783:sp_driver.S   **** 	movw	ZL, r24          ; Load R25:R24 into Z.
 784:sp_driver.S   **** 	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
 785:sp_driver.S   **** 	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
 786:sp_driver.S   **** 	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
 787:sp_driver.S   **** 	spm                      ; Self-program.
 788:sp_driver.S   **** 	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
 789:sp_driver.S   **** 	out	RAMPZ, r19       ; Restore RAMPZ register.
 790:sp_driver.S   **** 	ret
 791               		
 792               		
 793               	; END OF FILE
DEFINED SYMBOLS
         sp_driver.S:124    .text:00000000 SP_ReadByte
         sp_driver.S:148    .text:0000000c SP_ReadWord
         sp_driver.S:172    .text:0000001a SP_ReadCalibrationByte
         sp_driver.S:753    .text:0000014c SP_CommonLPM
         sp_driver.S:191    .text:0000001e SP_ReadUserSignatureByte
         sp_driver.S:210    .text:00000022 SP_ReadFuseByte
         sp_driver.S:722    .text:0000012c SP_CommonCMD
         sp_driver.S:236    .text:00000038 SP_WriteLockBits
         sp_driver.S:256    .text:00000040 SP_ReadLockBits
         sp_driver.S:275    .text:00000046 SP_EraseUserSignatureRow
         sp_driver.S:782    .text:00000156 SP_CommonSPM
         sp_driver.S:295    .text:0000004e SP_WriteUserSignatureRow
         sp_driver.S:315    .text:00000056 SP_EraseApplicationSection
         sp_driver.S:339    .text:00000064 SP_EraseApplicationPage
         sp_driver.S:363    .text:00000070 SP_LoadFlashWord
         sp_driver.S:388    .text:0000007a SP_LoadFlashPage
         sp_driver.S:405    .text:0000008c SP_LoadFlashPage_1
         sp_driver.S:442    .text:000000a0 SP_ReadFlashPage
         sp_driver.S:460    .text:000000b2 SP_ReadFlashPage_1
         sp_driver.S:494    .text:000000c2 SP_WriteApplicationPage
         sp_driver.S:518    .text:000000ce SP_EraseWriteApplicationPage
         sp_driver.S:540    .text:000000da SP_EraseFlashBuffer
         sp_driver.S:561    .text:000000e2 SP_EraseBootPage
         sp_driver.S:584    .text:000000ee SP_WriteBootPage
         sp_driver.S:608    .text:000000fa SP_EraseWriteBootPage
         sp_driver.S:630    .text:00000106 SP_ApplicationCRC
         sp_driver.S:649    .text:0000010a SP_BootCRC
         sp_driver.S:668    .text:0000010e SP_LockSPM
         sp_driver.S:693    .text:0000011c SP_WaitForSPM

NO UNDEFINED SYMBOLS
