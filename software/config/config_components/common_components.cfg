
network {
  udp_frame_size_bytes=1024;

  # Testing:
  # target_rate_bps=10000000; # set to 10Mbps (essentially non-restrictive) 
  # disable_pmd_custom_codecs = true;
  # disable_ers_custom_codecs = true;
  # disable_robot_plan_custom_codecs=true;

  #target_rate_bps=1000000; # set to 1Mbps (a little restrictive) 
  #disable_pmd_custom_codecs = false;
  #disable_ers_custom_codecs = true;
  #disable_robot_plan_custom_codecs= true;

  # Competition:
  target_rate_bps=95000; # set to 95kbps - competition (should be same as throughput_bps below for 250 ms latency case)
  fallback_seconds=50; # after these number of seconds at a rate other than the target_rate_bps (i.e. set adaptively for lower latency/higher throughput case), set back to target_rate_bps
  disallow_rate_change_seconds=15;

  disable_pmd_custom_codecs = false; #Procman custom compression
  disable_ers_custom_codecs = false; #EST_ROBOT_STATE custom compression
  disable_robot_plan_custom_codecs= false;

  latency=[50, 500];
  throughput_bps=[950000, 95000];

  expected_packet_loss_percent=5;

  robot {
      udp_host="172.19.5.2"; # Field Computer 1
      udp_port=9000;
  }
  base {
      udp_host="172.19.5.1"; # Main OCU
      udp_port=9001;
  }

  manipulation {
    robot_to_base {
      ########################################
      channels_a=["CAMERA_LEFT_TX","CAMERA_RIGHT_TX",
                  "CAMERALHAND_LEFT_TX", "CAMERARHAND_LEFT_TX",
                  "CAMERACHEST_LEFT_TX", "CAMERACHEST_RIGHT_TX",  
                  "CAMERA_LEFT_SUB","CAMERACHEST_LEFT_SUB","CAMERACHEST_RIGHT_SUB",
                  "MAP_OCTREE","MAP_CLOUD","MAP_DEPTH", "OGG_SERVER",
                  "MAP_CATALOG","MAP_LOCAL_CORRECTION",
                  "SYSTEM_STATUS","POSE_TAG",
                  "AFFORDANCE_PLUS_BASE_OVERWRITE","PMD_PRINTF_REPLY"];
      frequency_a=0.0;
      buffer_size_a=1;
      priority_a=0;

      ########################################
      channels_b=["PMD_INFO2"];
      frequency_b=0.0;
      buffer_size_b=10;
      priority_b=0;

      ########################################
      channels_c=["FREQUENCY_LCM", "ATLAS_STATUS", "CONTROLLER_STATUS"];
      frequency_c=1.0;
      buffer_size_c=1;
      priority_c=0;

      ########################################
      channels_d=["EST_ROBOT_STATE"];
      frequency_d=4.0;
      buffer_size_d=1;
      priority_d=2;
    }

    base_to_robot {
      ########################################
      channels_a=["MAP_REQUEST","SENSOR_REQUEST","SUBIMAGE_REQUEST",
                  "CAMERA_SETTINGS","MAP_DEPTH_SETTINGS",
                  "COMMITTED_FOOTSTEP_PLAN","PMD_ORDERS","PMD_ORDERS2","DATA_REQUEST",
                  "COMMITTED_ROBOT_PLAN","COMMITTED_GRASP",
                  "AFFORDANCE_PLUS_BOT_OVERWRITE","GAZE_COMMAND",
                  "DESIRED_NECK_PITCH","SIMPLE_GRASP_COMMAND",
                  "COMMITTED_MANIP_GAIN","COMMITTED_POSTURE_PRESET",
                  "PMD_PRINTF_REQUEST", "COMMITTED_PLAN_PAUSE","RECOVERY_CMD",
                  "COMMITTED_EE_ADJUSTMENT", "CONTROLLER_MODE", "MAP_CONTROLLER_COMMAND",
                  "COMMITTED_MANIP_MAP","MOTIONEST_REQUEST", "STOP_WALKING",
                  "MULTISENSE_COMMAND", "MAP_REQUEST_BBOX",
                  "IROBOT_LEFT_SIMPLE_GRASP", "IROBOT_RIGHT_SIMPLE_GRASP", 
                  "SANDIA_LEFT_SIMPLE_GRASP", "SANDIA_RIGHT_SIMPLE_GRASP", 
                  "IROBOT_RIGHT_CALIBRATE", "IROBOT_RIGHT_SPREAD", 
                  "IROBOT_RIGHT_POSITION_CONTROL_CLOSE", "IROBOT_RIGHT_CURRENT_CONTROL_CLOSE",
                  "IROBOT_LEFT_CALIBRATE", "IROBOT_LEFT_SPREAD",
                  "IROBOT_LEFT_POSITION_CONTROL_CLOSE", "IROBOT_LEFT_CURRENT_CONTROL_CLOSE",
                  "ROBOTIQ_LEFT_COMMAND", "ROBOTIQ_RIGHT_COMMAND",
                  "OGG_CLIENT", "PLAN_USING_BDI_HEIGHT",
                  "ATLAS_BEHAVIOR_COMMAND", "ATLAS_MANIPULATE_PARAMS", 
                  "CALIBRATE_ARM_ENCODERS","RESET_DRIVER_SAFETY"];
      frequency_a=0.0;
      buffer_size_a=10;
      priority_a=1;

      ########################################
      # send this so there's some constant traffic for the robot
      # to estimate latency from
      channels_b=["BASE_UTIME"];
      frequency_b=1.0;
      buffer_size_b=1;
      priority_b=0;

      ########################################
      channels_c=[];
      frequency_c=[1.0];
      buffer_size_c=1;
      priority_c=0;

      ########################################
      channels_d=[];
      frequency_d=[1.0];
      buffer_size_d=1;
      priority_d=0;
    }  
  }
}

frequency_tool {
    LCM { # must be caps | channels_short must be 4 chars
        #NBNBNB: dont change this list - its hard coded for easy transmission from robot to base
        channels       = ["EST_ROBOT_STATE","ATLAS_COMMAND","CAMERA","SCAN"];
        channels_short = ["ERS "           ,"ACOM"         ,"HEAD"  ,"SCAN"]; 
    }
}

driving {
    control {
        lookahead_distance_default = 11.0;
        kp_steer_default = 6.0;
    }
}

viewer {
  renderer_groups {
    manipulation {
      name="Manipulation";
      enabled=["BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control",
          "Affordances & StickyHands/Feet", "Collections" ];
    }

    walking {
      name="Walking";
      enabled=[ "BOT_FRAMES","Grid", "Maps", "Robot State Display","Robot Plan Display", "Data Control", "Walking",
          "Footstep Plans & Stick Feet" ];
    }
  }

  datacontrol_presets {

    all {
      label = "All";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 1;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 1;  quality = 1; }
      Scene_Height    { enable = 1;  period = 1; }
      Scene_Depth     { enable = 1;  period = 1; }
      Workspace_Depth { enable = 1;  period = 1;  fov = 90;  yaw = 0; }
    }

    camera_only {
      label = "Camera Only";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 0;  period = 0;  quality = 1; }
      Camera_R_Chest  { enable = 0;  period = 0;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 0;  period = 0; }
    }

    camera_lidar {
      label = "Camera + Hi Lidar";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 5;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 5;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 1;  period = 1; }
    }

    camera_low_lidar {
      label = "Camera + Low Lidar";
      Camera_Head     { enable = 1;  period = 1;  quality = 1; }
      Camera_L_Chest  { enable = 1;  period = 5;  quality = 1; }
      Camera_R_Chest  { enable = 1;  period = 5;  quality = 1; }
      Scene_Height    { enable = 0;  period = 0; }
      Scene_Depth     { enable = 0;  period = 0; }
      Workspace_Depth { enable = 1;  period = 5; }
    }
  }
}




state_estimator {
  # when processing from log set
  # false: republish_sensors, republish_cameras, publish_filter_state, gpf_vis, publish_diagnostics
  # true:  republish_incoming_poses (POSE_VICON & BDI)
  
  # when processing gpf:
  # init from vicon and ins but not pose_meas
  # use VICON_BODY when doing GPF from file
  # gpf_vis = false
  # additionally when running gpf out of process: 
  # publish_filter_state=true

  
  # when running on robot use pose_meas to start from BDI Pose
    
  pose_channel = "POSE_BODY"; # was POSE_BODY_ALT
  filter_state_channel = "STATE_ESTIMATOR_STATE";
  # the frame at which to draw convariance information in viewer
  pose_render_frame = "body"; # was body_alt
  
  publish_filter_state = true; #publish alongside pose
  publish_pose = true;
  republish_sensors = false; # if using a log, otherwise make s
  init_sensors = ["ins"];# ins,vicon, pose_meas

  #"laser_gpf","ins","rgbd_gpf","fovis","legodo","vicon","pose_meas"
  #active_sensors = ["ins"];
  active_sensors = ["ins","legodo", "laser_gpf_out_of_process"];#,""];#, ];

  # was this: 1000000 (1sec) for mav
  utime_history_span =1000000;

  #initial state estimate (relavent states overridden by init sensors)
  sigma0 {
          vb = 0.15; #m/s
          chi_xy = 3.0; #degrees
          chi_z = 3.0; #degrees
          Delta_xy = 0.05;#.5; #m
          Delta_z = 0.05;#1;    #m
          
          gyro_bias = 0; #deg/seg
          accel_bias = 0; #m/s^2
  }
  
  ## typical atlas height
  x0 {
    velocity = [0,0,0];
    angular_velocity = [0,0,0];
    position = [0, 1, 0.85];
    rpy = [0, 0, 2.1];
  }  

  # 2014-01-21-16-19-robot-long-stepping POSE_BDI
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [2.1455, 1.8037, 1.15523];
  #  rpy = [0, 0.0, 0.91];
  #}  

  # 2014-01-21-16-20-robot-typical-stepping POSE_BDI
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [1.13491, 0.738823, 0.943194];
  #  rpy = [0.000706219, 0.00482811,   0.656877];
  #}
  
  # 2014-01-21-16-20-robot-typical-stepping POSE_VICON
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [-0.26285741, 0.040719547, 0.839928];
  #  rpy = [-0.01110456192, -0.00299640, 0.15224167];
  #}

  # 2014-01-21-17-00-robot-dynamic2 POSE_VICON
  #x0 {
  #  velocity = [0,0,0];
  #  angular_velocity = [0,0,0];
  #  position = [0.6514936211570106, 0.049159189817775714, 0.8462076325052497];
  #  rpy = [-0.009818276073750867, -0.003101104289359788, 0.13200005199560214];
  #}
  
  
  
  init_message {
    channel = "MAV_STATE_EST_INITIALIZER";
  }

  viewer {
    channel = "MAV_STATE_EST_VIEWER_MEASUREMENT";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;
  }

  ins {
    channel ="ATLAS_IMU_BATCH"; # "ATLAS_IMU_BATCH_FILTERED", "MICROSTRAIN_INS";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 3; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = true;

    # microstrain: 0.5 | 0.2
    q_gyro = 0.5; #deg/sec
    q_accel = 0.2; #m/s^2       
    q_gyro_bias = 0; #deg/seg^2
    q_accel_bias = 0; #m/sec^2/sec
    frame = "imu";
    
    #ms     
    #timestep_dt = 0.01; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    #bdi
    timestep_dt = 0.003333; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    
    num_to_init = 333; # was 100 for microstrain
    
    # apply notch filtering on input: (to atlas imu accel signals)
    atlas_filter = true;
  }

  gps{
    channel = "UBLOX_GPS_DATA";
    #utime_offset = 273200; #.27 second delay optimized for on 11-05-03-outdoors.01
    utime_offset = 145000; #.145 second delay from fixie-gps-2012-05-12.02
    #utime_offset = 0;
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xy = 2.0; #m
    r_z = 2.0; #m
  }

  vicon{
    channel = "VICON_BODY";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 10; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees
    
    # typically position was used
    mode="position"; # "position_orient"
    
    # added mfallon, apply this transform to put vicon in body frame
    # as vicon data is assumed to be in the frame defined by Vicon's software
    apply_frame = true;
    frame_from = "body_vicon";
    frame_to = "frontplate_vicon";
  }

  # correct the pose to this value: (to init using Pose BDI)
  pose_meas{
    no_corrections = 100; # apply this number of corrections before going silent
    channel = "POSE_BDI";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 10; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees
    
    mode="position_orient"; # "position" "position_orient"
  }  
  
  laser_gpf_out_of_process { 
    utime_offset = 0; 
    downsample_factor = 1; # i dont think this is used
    channel = "GPF_MEASUREMENT";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  laser_gpf {
    utime_offset = 0; 
    downsample_factor = 3; 
    channel = "SCAN";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    gpf_vis = false;

    # N9:
    #map_name = "/home/mfallon/data/atlas/2014-01-21-vicon-walking/octomap/n9-2014-01-21.bt_blurred_0.5";          
    map_name = "octomap.bt_blurred";    
    #map_name = "from_lcm"; # this means it will be transmitted at launch
    blur_sigma = 0.3;# 0.3 # added by mfallon. was 0.5 previously in a stand alone process

    # 300 is bare min
    gpf_num_samples = 500; # 1000 seemed to be noticably better than 500
    
    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    # mfallon: drc initially used pos_yaw
    gpf_substate = "pos_yaw";
    
    #laser projection settings
    projection_mode = "motion_interpolate"; # just added, this was motion_project by default, but now using motion_interpolate.
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;
    
    #-----------gpf probability settings-----------
    
    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13
    
    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    # mfallon, jan 2014: mav used 8.16. I'm going to use something much smaller, mfallon
    # mfallon, mar 2014: i think this should actually be higher if not decimating
    sigma_scaling = 8.16; #should be identical to "adams magic scaling factor used for johnson/parking garage 2012-5-13
  }


  rgbd_gpf { 
    utime_offset = 0; #units 1e-6 seconds   
    #if running in a separate process the downsampling is applied before processing, and as many as can be processed will be (it will hog cpu)
    # laser 40Hz df: 3 | rgbd 10Hz df: 1
    downsample_factor = 1; # process 1 out of every this many laser readings (come at 40hz)

    #channel = "RGBD_GPF_MEASUREMENT";
    channel = "KINECT_FRAME";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    
    
    # N9:
    map_name = "rgbd_octomap.bt_blurred_0.5";
    gpf_vis = true;

    # 300 is bare min
    gpf_num_samples = 500; 
    
    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    gpf_substate = "pos_yaw";
    
    #laser projection settings
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;
    
    #-----------gpf probability settings-----------
    
    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13
    
    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    sigma_scaling = 3; #3 or  8.16 should be identical to adams magic scaling factor used for johnson/parking garage 2012-5-13
  }


  fovis {

    channel = "KINECT_REL_ODOMETRY";
    mode = "lin_rate"; # linear and rotation rates i.e. velocities
    
    # velocity variances:
    # 0.50 looks good for very difficult logs
    r_vxyz = 5.0;  # m/s
    # scan matchered used 1.0
    r_vang  = 0.50;  # degrees?

    utime_offset = 0;
    downsample_factor = 1;
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  legodo {

    channel = "ATLAS_STATE"; #"EST_ROBOT_STATE";
    # lin_rate           linear velocities
    # lin_rot_rate       linear and rotation rates i.e. velocities
    # pos_and_lin_rate   position and linear velocities
    mode = "lin_rate"; 
    
    # [velocity] variances:
    # 5.0 had no effect on the corrections
    # @ 330Hz:
    # 0.1 is too low - the corrections made wheren't physically possible   
    # 0.5 the SE velocity tracks the kinematics - but too closely corrects to spikes
    #     when foot contacts occur the velocities spike. need to classify 
    # 0.25 was what I used in later development
    r_vxyz = 0.25;  # m/s
    # reasonable for 33Hz:
    #r_vxyz = .1;  # m/s
    # scan matchered used 1.0
    r_vang  = 0.50;  # degrees?

    #### Variance for uncertain walking kinematics e.g. breaking and making contact
    # Setting equal to the above values makes this mode disabled 
    # 0.75 and 1.00 worked well on batch processing
    r_vxyz_uncertain = 0.25;# 0.75;
    r_vang_uncertain = 0.50;# 1.00;
    
    ##########################
    ## Variance for Direct [Position] Measurement [NEW]
    # shared between modes
    # 1-2 looks good ( at ~280Hz )
    # 4 twitch is beginning to appear
    r_xyz = 2.0; 
    
    utime_offset = 0;
    downsample_factor = 3; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    
    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "zero";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always"; 
    
    # Republish various channels (if reading from a log)
    republish_incoming_poses = false; # republish POSE_VICON and POSE_BDI to the log
    republish_cameras = false;
    publish_diagnostics = false;
    
    # either foot or talus:
    standing_link = "foot";
    
    # filter joint positions: t/f
    filter_joint_positions = true;
    
    # filter kinematics when we think contact occurs
    filter_contact_events = true;
  }
  
  legodo_external {

    # Channel Subscribed to:
    channel = "LEG_ODOMETRY_DELTA";
    
    # All other parameters are taken from legodo block
  }  
 
 
  # These setting are only used by the leg odometry driven process: se-leg-odometry
  legodo_driven_process {
    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "bdi";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always"; 
  }
  
}
  
  
  
  
control{
  
  # Use these encoder offsets, updated after calibration
  # no need to include 16:27 here:
  # index 3 is the neck. 4.24 as of v.1.10 robot software
  encoder_offsets{
    index =     [3,    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27];
    value =     [4.24,1.0767,1.0598,0.88921,1.0655,-0.008518,0.99081,-1.0456,-1.0671,-0.19057,-1.0478,-1.0525,-0.93257];
  }
  
  filtering{
    
    index = [4,5,6,7,8,9,10,11,12,13,14,15]; # legs
    #index = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; # full robot
    process_noise = 0.01;
    observation_noise = 5E-4;
  }
  
}

